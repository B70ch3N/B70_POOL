---
title: 通信软件基础实验03
date: 2022-10-13 18:24:20
tags: c语言
---

## 写在前面

目前仅有源代码，详细内容后续更新

<!--more-->

```c
/*
IDE:Visual Studio 2022
字符集:Unicode
文本文档编码：ANSI
参考：BV1zz4y1m7Nq，BV1Tg411F7Jp
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAXVEX 20//最大顶点数
#define GRAPH_INFINTY 32767//无限，表未连接


struct Graph//图结构体
{
    char city_name[MAXVEX][20];//记录节点名称
    int arc[MAXVEX][MAXVEX];//邻接矩阵
    int vex_num;//定点数
};

int CreateGraph(struct Graph *G)//读取文件生成图函数
{
	FILE* fp;
    int X, Y, W;//行，列，权值
	if ((fp = fopen("Dijkstra_input.txt", "r")) == NULL)//打开文件
	{
		printf("打开文件错误");
		return;
	}
    fscanf(fp, "节点个数：");
	fscanf(fp, "%d", &G->vex_num);
    printf("节点个数： % d\n", G->vex_num);
    fscanf(fp, "节点名称：");
    for (int i = 0; i < G->vex_num; i++)
    {
        fscanf(fp, "%s", G->city_name[i]);
        printf("节点%d：%s\n",i+1, G->city_name[i]);
    }

    for (int i = 0; i < G->vex_num; i++)//对图赋初值
    {
        for (int j = 0; j < G->vex_num; j++)
        {
            G->arc[i][j] = GRAPH_INFINTY;//初始皆为断开
        }
		G->arc[i][i] = 0;//无自环
    }
    printf("\n已有边关系：\n");
    for (int i = 0;; i++)//读取文件获取边
    {
        if (fscanf(fp, "%d %d %d", &X, &Y, &W) == EOF)
            break;
        else
        {
            //无向图邻接矩阵对称
            G->arc[X-1][Y-1] = W;
            G->arc[Y-1][X-1] = W;
            printf("节点\"%s\"-节点\"%s\"路径长度：%d\n",G->city_name[X - 1],G->city_name[Y - 1], W);
        }
    }
    return G->vex_num;
}

int getMin(int* d, int* s, struct Graph* G) 
{
    int min = GRAPH_INFINTY;
    int index;
    for (int i = 0; i < G->vex_num; i++) 
    {
        if (s[i] == 0 && d[i] < min)//未确定节点最短路径且当前路径小于已有路径长度最小值 
        {
            //更新min与索引
            min = d[i];
            index = i;
        }
    }
    return index;
}

void printDijkstra(int cityNow, int* s, int* p, int* d, struct Graph* G)//输出源节点到各节点的最短路径信息
{
    int* fd = (int*)malloc(sizeof(int) * G->vex_num);//生成动态数组，保存下标序列，便于输出信息
    int pos;//哨兵，记录当前位置前驱
    printf("\n节点%d%s",cityNow+1, G->city_name[cityNow]);
    printf("到各节点信息：\n");
    for (int i = 0; i < G->vex_num; i++)
    {
        if (i == cityNow)//忽略自环
            continue;
        pos = p[i];//记录前驱
        printf("节点\"%s\"-节点\"%s\"最短路径长度：%d\n路径：", G->city_name[cityNow], G->city_name[i], d[i]);
        for (int j = 0; j < G->vex_num; j++)
        {
            fd[j] = pos;//将前驱写入序列
            pos = p[pos];//更新位置，写入新的前驱
            if (pos == -1)//到源节点时进行输出
            {
                for (; j >= 0; j--)//将路径正序输出
                {
                    printf("%s->", G->city_name[fd[j]]);
                }
                printf("%s\n", G->city_name[i]);
                break;
            }
                
        }
    }

}

void Dijkstra(struct Graph* G, int index)//Dijkstra算法核心 
{
    // 准备辅助数组
    int* s = (int*)malloc(sizeof(int) * G->vex_num);//s数组记录是否找到对应节点最短路径，1-找到、0未找到
    int* p = (int*)malloc(sizeof(int) * G->vex_num);//p数组记录当前节点的前驱节点
    int* d = (int*)malloc(sizeof(int) * G->vex_num);//d数组记录最初节点到当前节点的路径长度
    int cityNow = index;
    // 初始化辅助数组
    for (int i = 0; i < G->vex_num; i++) 
    {
        if (G->arc[index][i] > 0 && G->arc[index][i] != GRAPH_INFINTY)//非自身且非断路
        {
            d[i] = G->arc[index][i];//初始化路径长度
            p[i] = index;//初始化前驱
        }
        else 
        {
            d[i] = GRAPH_INFINTY;
            p[i] = -1;//-1表示无节点
        }
        if (i == index) 
        {
            s[i] = 1;//源节点极为最近路径必经节点，赋1
            d[i] = 0;//路径长度0
        }
        else
            s[i] = 0;//其余节点为确定最短路径赋0
    }
    //寻找到各节点的最短路径
    for (int i = 0; i < G->vex_num - 1; i++) 
    {
        index = getMin(d, s, G);
        s[index] = 1;//找到当前节点的最短路径
        for (int j = 0; j < G->vex_num; j++) 
        {
            if (s[j] == 0 && d[index] + G->arc[index][j] < d[j])//未找到最短路径且当前路径长度小于已有路径，更新信息 
            {
                d[j] = d[index] + G->arc[index][j];//更新路径长度
                p[j] = index;//记录前驱
            }
        }
    }
    /*//检测算法，调试用
    for (int i = 0; i < G->vex_num; i++)
    {
        printf("%d %d %d\n", s[i], p[i], d[i]);
    }
    */
    printDijkstra(cityNow,s,p, d, G);
}



void main()
{
    int index;//索引
    struct Graph G;//生成图
    CreateGraph(&G);//初始化图
    while (1)
    {
        printf("\n请输入求最短路径的节点：");
        scanf("%d", &index);
        if ((index - 1 < G.vex_num) && (index > 0))
            break;
        else
            printf("输入错误\n");
    }
    Dijkstra(&G, index - 1);

```

